package compose 

import (
	"os"
	"path"
	"path/filepath"

	wundertools_config "github.com/james-nesbitt/wundertools-go/config"
	wundertools_log "github.com/james-nesbitt/wundertools-go/log"

	"github.com/docker/libcompose/config"
	"github.com/docker/libcompose/docker"
	"github.com/docker/libcompose/docker/client"
	"github.com/docker/libcompose/lookup"
	"github.com/docker/libcompose/project"
)

// Duplicate {libcompose}docker.NewProject, but make it return a Project, instead of an APIProject
func NewLibComposeProject(logger wundertools_log.Log, application *wundertools_config.Application) (*project.Project, error) {

	composeProjectName := application.Name
	composeFiles := []string{}

	if yamlPath, ok := application.Paths.Path("project-wundertools"); ok {
		yamlPath = path.Join(yamlPath, "docker-compose.yml")
		composeFiles = append(composeFiles, yamlPath)
	}

	var context *docker.Context = &docker.Context{
		Context: project.Context{
			ComposeFiles: composeFiles,
			ProjectName:  composeProjectName,
		},
	}
	var parseOptions *config.ParseOptions

	if context.ResourceLookup == nil {
		context.ResourceLookup = &lookup.FileConfigLookup{}
	}

	if context.EnvironmentLookup == nil {
		cwd, err := os.Getwd()
		if err != nil {
			return nil, err
		}
		context.EnvironmentLookup = &lookup.ComposableEnvLookup{
			Lookups: []config.EnvironmentLookup{
				&lookup.EnvfileLookup{
					Path: filepath.Join(cwd, ".env"),
				},
				&lookup.OsEnvLookup{},
			},
		}
	}

	if context.AuthLookup == nil {
		context.AuthLookup = docker.NewConfigAuthLookup(context)
	}

	if context.ServiceFactory == nil {
		context.ServiceFactory = &ServiceFactory{
			context: context,
		}
	}

	if context.ClientFactory == nil {
		factory, err := client.NewDefaultFactory(client.Options{})
		if err != nil {
			return nil, err
		}
		context.ClientFactory = factory
	}

	// FIXME(vdemeester) Remove the context duplication ?
	runtime := &Project{
		clientFactory: context.ClientFactory,
	}
	p := project.NewProject(&context.Context, runtime, parseOptions)

	err := p.Parse()
	if err != nil {
		return nil, err
	}

	if err = context.open(); err != nil {
		logrus.Errorf("Failed to open project %s: %v", p.Name, err)
		return nil, err
	}

	return &p, err
}


// ServiceFactory is an implementation of project.ServiceFactory.
type ServiceFactory struct {
	context *docker.Context
}

// Create creates a Service based on the specified project, name and service configuration.
func (s *ServiceFactory) Create(project *project.Project, name string, serviceConfig *config.ServiceConfig) (project.Service, error) {
	return NewService(name, serviceConfig, s.context), nil
}


// Project implements project.RuntimeProject and define docker runtime specific methods.
type Project struct {
	clientFactory client.Factory
}

// RemoveOrphans implements project.RuntimeProject.RemoveOrphans.
// It will remove orphan containers that are part of the project but not to any services.
func (p *Project) RemoveOrphans(ctx context.Context, projectName string, serviceConfigs *config.ServiceConfigs) error {
	client := p.clientFactory.Create(nil)
	filter := filters.NewArgs()
	filter.Add("label", labels.PROJECT.EqString(projectName))
	containers, err := client.ContainerList(ctx, types.ContainerListOptions{
		Filter: filter,
	})
	if err != nil {
		return err
	}
	currentServices := map[string]struct{}{}
	for _, serviceName := range serviceConfigs.Keys() {
		currentServices[serviceName] = struct{}{}
	}
	for _, container := range containers {
		serviceLabel := container.Labels[labels.SERVICE.Str()]
		if _, ok := currentServices[serviceLabel]; !ok {
			if err := client.ContainerKill(ctx, container.ID, "SIGKILL"); err != nil {
				return err
			}
			if err := client.ContainerRemove(ctx, container.ID, types.ContainerRemoveOptions{
				Force: true,
			}); err != nil {
				return err
			}
		}
	}
	return nil
}
